[
  {
    "objectID": "jan13.html",
    "href": "jan13.html",
    "title": "Monte Carlo Simulations",
    "section": "",
    "text": "Recall that we found that if \\(X_1, X_2\\sim U(0, 1)\\), then the minimum \\(X_{(1)}\\) has probability density function \\(f_{X_{(1)}}(x) = 2(1-x)\\). Integrating, its cumulative distribution function (on the unit interval) is \\[\\begin{align}\nF_{X_{(1)}}(x) &= \\int_0^x 2(1 - t)\\,dt \\\\\n&= -(1-t)^2\\Big|_0^x \\\\\n&= -(1-x)^2 + (1 - 0)^2 \\\\\n&= -1 + 2x - x^2 + 1 \\\\\n&= -x^2 + 2x\n\\end{align}\\]\nLet’s check this with some Monte Carlo simulations. For example, we should expect that the probability that our minimum is less than \\(\\frac{1}{2}\\) is\n\\[F_{X_{(1)}}(0.5) = -0.5^2 + 2\\cdot 0.5 = 0.75\\]\nRecall that runif(2) will generate a random sample from our, and min(runif(2)) will give us the minimum. We can do this multiple times with replicate:\n\nreplicate(10, min(runif(2)))\n\n [1] 0.67468700 0.44783443 0.03612652 0.34445951 0.02099621 0.05980279\n [7] 0.20105532 0.04022018 0.55169667 0.01815948\n\n\nWe’re interested in finding the number of our random samples that were less than 0.5. If we replicate a statement, we’ll get a list of a bunch of boolean (TRUE or FALSE) objects.\n\nreplicate(10, min(runif(2)) &lt; 0.5)\n\n [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n\n\nR treats these Boolean objects like integers (0 for FALSE and 1 for TRUE), so we can compute the proportion of TRUE’s by taking the mean:\n\nmean(replicate(10, min(runif(2)) &lt; 0.5))\n\n[1] 0.9\n\n\nNow let’s increase the sample size:\n\nmean(replicate(10000, min(runif(2)) &lt; 0.5))\n\n[1] 0.7429\n\n\nWe got pretty close to our theoretical result of 0.75!"
  },
  {
    "objectID": "jan15.html",
    "href": "jan15.html",
    "title": "Monte Carlo simulations for the beta distribution",
    "section": "",
    "text": "Recall that if \\(X\\) has the beta distribution with shape parameters \\(\\alpha\\) and \\(\\beta\\), i.e., \\(X\\sym\\operatorname{Beta}(\\alpha,\\beta)\\), then \\(X\\) has probability density function\n\\[f_X(x) = \\begin{cases}\n\\frac{1}{B(\\alpha)(\\beta)}x^{\\alpha - 1}(1 - x)^{\\beta - 1} & \\text{if }0 &lt; x &lt; 1 \\\\\n0 & \\text{otherwise,}\n\\end{cases}\n\\] where \\(B\\) is the beta function given by \\[B(\\alpha,\\beta) = \\int_0^1x^{\\alpha - 1}(1 - x)^{\\beta - 1}\\,dx = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha + \\beta)}.\\]\nWe saw in class that if \\(X_1,X_2\\sym\\operatorname{Beta}(2, 1)\\), then their sample mean \\(\\overline X\\) has cumulative distribution function \\[\nF_{\\overline X}(z) = \\begin{cases}\n0 &\\text{if }z \\leq 0 \\\\\n\\frac{8}{3}z^4 &\\text{if } 0 &lt; z \\leq\\frac{1}{2} \\\\\n-\\frac{8}{3}z^4 + 8z^2 - \\frac{16}{3}z + 1 &\\text{if }\\frac{1}{2} &lt; z &lt; 1 \\\\\n1 &\\text{if }z \\geq 1\\\\\n\\end{cases}\n\\] ## Monte Carlo simulation\nFirst, let’s define an R function to evaluate our cdf from above:\n\nF &lt;- function(z) {\n  if (z &lt;= 0) {\n    return(0)\n  } else if (z &lt;= 1/2) {\n    return(8/3 * z^4)\n  } else if (z &lt; 1 ) {\n    return (-8/3 * z^4 + 8*z^2 - 16/3*z + 1)\n  } else {\n    return(1)\n  }\n}\n\nNext, we can use R to generate a random sample of \\(\\overline X\\) by first using rbeta(2, 2, 1) to generate 2 random samples from a \\(\\operatorname{Beta}(2, 1)\\) distribution, and then mean to find their sample mean.\n\nmean(rbeta(2,2,1))\n\n[1] 0.5649408\n\n\nTo perform our Monte Carlo simulation, we use replicate to perform the process a bunch of times. Each time, we compare to some value, yielding TRUE or FALSE, and then mean to find the proportion of TRUE’s. (Since TRUE is treated like 1 and FALSE like 0.)\nLet’s choose several different choices for \\(z\\) and compare the theoretical results with our simulated results.\n\nz &lt;- 0.25\nF(z)\n\n[1] 0.01041667\n\nmean(replicate(10000, mean(rbeta(2,2,1)) &lt; z))\n\n[1] 0.0095\n\n\n\nz &lt;- 0.5\nF(z)\n\n[1] 0.1666667\n\nmean(replicate(10000, mean(rbeta(2,2,1)) &lt; z))\n\n[1] 0.1694\n\n\n\nz &lt;- 0.75\nF(z)\n\n[1] 0.65625\n\nmean(replicate(10000, mean(rbeta(2,2,1)) &lt; z))\n\n[1] 0.66\n\n\nNot bad!"
  },
  {
    "objectID": "jan15.html#beta-distribution",
    "href": "jan15.html#beta-distribution",
    "title": "Monte Carlo simulations for the beta distribution",
    "section": "",
    "text": "Recall that if \\(X\\) has the beta distribution with shape parameters \\(\\alpha\\) and \\(\\beta\\), i.e., \\(X\\sym\\operatorname{Beta}(\\alpha,\\beta)\\), then \\(X\\) has probability density function\n\\[f_X(x) = \\begin{cases}\n\\frac{1}{B(\\alpha)(\\beta)}x^{\\alpha - 1}(1 - x)^{\\beta - 1} & \\text{if }0 &lt; x &lt; 1 \\\\\n0 & \\text{otherwise,}\n\\end{cases}\n\\] where \\(B\\) is the beta function given by \\[B(\\alpha,\\beta) = \\int_0^1x^{\\alpha - 1}(1 - x)^{\\beta - 1}\\,dx = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha + \\beta)}.\\]\nWe saw in class that if \\(X_1,X_2\\sym\\operatorname{Beta}(2, 1)\\), then their sample mean \\(\\overline X\\) has cumulative distribution function \\[\nF_{\\overline X}(z) = \\begin{cases}\n0 &\\text{if }z \\leq 0 \\\\\n\\frac{8}{3}z^4 &\\text{if } 0 &lt; z \\leq\\frac{1}{2} \\\\\n-\\frac{8}{3}z^4 + 8z^2 - \\frac{16}{3}z + 1 &\\text{if }\\frac{1}{2} &lt; z &lt; 1 \\\\\n1 &\\text{if }z \\geq 1\\\\\n\\end{cases}\n\\] ## Monte Carlo simulation\nFirst, let’s define an R function to evaluate our cdf from above:\n\nF &lt;- function(z) {\n  if (z &lt;= 0) {\n    return(0)\n  } else if (z &lt;= 1/2) {\n    return(8/3 * z^4)\n  } else if (z &lt; 1 ) {\n    return (-8/3 * z^4 + 8*z^2 - 16/3*z + 1)\n  } else {\n    return(1)\n  }\n}\n\nNext, we can use R to generate a random sample of \\(\\overline X\\) by first using rbeta(2, 2, 1) to generate 2 random samples from a \\(\\operatorname{Beta}(2, 1)\\) distribution, and then mean to find their sample mean.\n\nmean(rbeta(2,2,1))\n\n[1] 0.5649408\n\n\nTo perform our Monte Carlo simulation, we use replicate to perform the process a bunch of times. Each time, we compare to some value, yielding TRUE or FALSE, and then mean to find the proportion of TRUE’s. (Since TRUE is treated like 1 and FALSE like 0.)\nLet’s choose several different choices for \\(z\\) and compare the theoretical results with our simulated results.\n\nz &lt;- 0.25\nF(z)\n\n[1] 0.01041667\n\nmean(replicate(10000, mean(rbeta(2,2,1)) &lt; z))\n\n[1] 0.0095\n\n\n\nz &lt;- 0.5\nF(z)\n\n[1] 0.1666667\n\nmean(replicate(10000, mean(rbeta(2,2,1)) &lt; z))\n\n[1] 0.1694\n\n\n\nz &lt;- 0.75\nF(z)\n\n[1] 0.65625\n\nmean(replicate(10000, mean(rbeta(2,2,1)) &lt; z))\n\n[1] 0.66\n\n\nNot bad!"
  },
  {
    "objectID": "jan8.html",
    "href": "jan8.html",
    "title": "Statistical Graphics",
    "section": "",
    "text": "Statistical Graphics\nWe will use the software platform R to do many computations.\nR comes with various builtin datasets to play around with.\n\nHairEyeColor\n\n, , Sex = Male\n\n       Eye\nHair    Brown Blue Hazel Green\n  Black    32   11    10     3\n  Brown    53   50    25    15\n  Red      10   10     7     7\n  Blond     3   30     5     8\n\n, , Sex = Female\n\n       Eye\nHair    Brown Blue Hazel Green\n  Black    36    9     5     2\n  Brown    66   34    29    14\n  Red      16    7     7     7\n  Blond     4   64     5     8\n\n\nThere are various ways to represent data visually using graphics. One example is a “mosaic plot”:\n\nmosaicplot(~ Eye + Sex, data=HairEyeColor)\n\n\n\n\n\n\n\n\nVisually, it appears that hair and eye color may be independent from sex, but eye and hair color may be dependent on each other.\nWe can import data sets using the scan function:\n\nspeed.of.light &lt;- scan(\"michelson1.d\")\nsort(speed.of.light)\n\n  [1]  620  650  720  720  720  740  740  740  750  760  760  760  760  760  770\n [16]  780  780  790  790  790  800  800  800  800  800  810  810  810  810  810\n [31]  810  810  810  810  810  820  820  830  830  840  840  840  840  840  840\n [46]  840  840  850  850  850  850  850  850  850  850  860  860  860  870  870\n [61]  870  870  880  880  880  880  880  880  880  880  880  880  890  890  890\n [76]  900  900  910  910  920  930  930  940  940  940  950  950  950  960  960\n [91]  960  960  970  980  980  980 1000 1000 1000 1070\n\nstem(speed.of.light)\n\n\n  The decimal point is 2 digit(s) to the right of the |\n\n   6 | 2\n   6 | 5\n   7 | 222444\n   7 | 566666788999\n   8 | 000001111111111223344444444\n   8 | 5555555566677778888888888999\n   9 | 0011233444\n   9 | 55566667888\n  10 | 000\n  10 | 7\n\n\n\nhist(speed.of.light)\n\n\n\n\n\n\n\n\nBased on these graphics, it appears that these measurements may come from a normal distribution.\n\nboxplot(speed.of.light)\n\n\n\n\n\n\n\n\n\nquantile(speed.of.light, c(0, 0.25, 0.5, 0.75, 1))\n\n    0%    25%    50%    75%   100% \n 620.0  807.5  850.0  892.5 1070.0 \n\n\n\nplot.ecdf(speed.of.light, ylab=\"F_n(x)\")\n\n\n\n\n\n\n\n\n\nhelp(plot.ecdf)"
  }
]