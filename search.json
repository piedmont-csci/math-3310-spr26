[
  {
    "objectID": "jan13.html",
    "href": "jan13.html",
    "title": "Monte Carlo Simulations",
    "section": "",
    "text": "Recall that we found that if \\(X_1, X_2\\sim U(0, 1)\\), then the minimum \\(X_{(1)}\\) has probability density function \\(f_{X_{(1)}}(x) = 2(1-x)\\). Integrating, its cumulative distribution function (on the unit interval) is \\[\\begin{align}\nF_{X_{(1)}}(x) &= \\int_0^x 2(1 - t)\\,dt \\\\\n&= -(1-t)^2\\Big|_0^x \\\\\n&= -(1-x)^2 + (1 - 0)^2 \\\\\n&= -1 + 2x - x^2 + 1 \\\\\n&= -x^2 + 2x\n\\end{align}\\]\nLet’s check this with some Monte Carlo simulations. For example, we should expect that the probability that our minimum is less than \\(\\frac{1}{2}\\) is\n\\[F_{X_{(1)}}(0.5) = -0.5^2 + 2\\cdot 0.5 = 0.75\\]\nRecall that runif(2) will generate a random sample from our, and min(runif(2)) will give us the minimum. We can do this multiple times with replicate:\n\nreplicate(10, min(runif(2)))\n\n [1] 0.42461779 0.09690192 0.16034092 0.27361333 0.48174590 0.33733373\n [7] 0.27934346 0.28112558 0.67605595 0.65237166\n\n\nWe’re interested in finding the number of our random samples that were less than 0.5. If we replicate a statement, we’ll get a list of a bunch of boolean (TRUE or FALSE) objects.\n\nreplicate(10, min(runif(2)) &lt; 0.5)\n\n [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n\n\nR treats these Boolean objects like integers (0 for FALSE and 1 for TRUE), so we can compute the proportion of TRUE’s by taking the mean:\n\nmean(replicate(10, min(runif(2)) &lt; 0.5))\n\n[1] 0.8\n\n\nNow let’s increase the sample size:\n\nmean(replicate(10000, min(runif(2)) &lt; 0.5))\n\n[1] 0.7475\n\n\nWe got pretty close to our theoretical result of 0.75!"
  },
  {
    "objectID": "jan8.html",
    "href": "jan8.html",
    "title": "Statistical Graphics",
    "section": "",
    "text": "Statistical Graphics\nWe will use the software platform R to do many computations.\nR comes with various builtin datasets to play around with.\n\nHairEyeColor\n\n, , Sex = Male\n\n       Eye\nHair    Brown Blue Hazel Green\n  Black    32   11    10     3\n  Brown    53   50    25    15\n  Red      10   10     7     7\n  Blond     3   30     5     8\n\n, , Sex = Female\n\n       Eye\nHair    Brown Blue Hazel Green\n  Black    36    9     5     2\n  Brown    66   34    29    14\n  Red      16    7     7     7\n  Blond     4   64     5     8\n\n\nThere are various ways to represent data visually using graphics. One example is a “mosaic plot”:\n\nmosaicplot(~ Eye + Sex, data=HairEyeColor)\n\n\n\n\n\n\n\n\nVisually, it appears that hair and eye color may be independent from sex, but eye and hair color may be dependent on each other.\nWe can import data sets using the scan function:\n\nspeed.of.light &lt;- scan(\"michelson1.d\")\nsort(speed.of.light)\n\n  [1]  620  650  720  720  720  740  740  740  750  760  760  760  760  760  770\n [16]  780  780  790  790  790  800  800  800  800  800  810  810  810  810  810\n [31]  810  810  810  810  810  820  820  830  830  840  840  840  840  840  840\n [46]  840  840  850  850  850  850  850  850  850  850  860  860  860  870  870\n [61]  870  870  880  880  880  880  880  880  880  880  880  880  890  890  890\n [76]  900  900  910  910  920  930  930  940  940  940  950  950  950  960  960\n [91]  960  960  970  980  980  980 1000 1000 1000 1070\n\nstem(speed.of.light)\n\n\n  The decimal point is 2 digit(s) to the right of the |\n\n   6 | 2\n   6 | 5\n   7 | 222444\n   7 | 566666788999\n   8 | 000001111111111223344444444\n   8 | 5555555566677778888888888999\n   9 | 0011233444\n   9 | 55566667888\n  10 | 000\n  10 | 7\n\n\n\nhist(speed.of.light)\n\n\n\n\n\n\n\n\nBased on these graphics, it appears that these measurements may come from a normal distribution.\n\nboxplot(speed.of.light)\n\n\n\n\n\n\n\n\n\nquantile(speed.of.light, c(0, 0.25, 0.5, 0.75, 1))\n\n    0%    25%    50%    75%   100% \n 620.0  807.5  850.0  892.5 1070.0 \n\n\n\nplot.ecdf(speed.of.light, ylab=\"F_n(x)\")\n\n\n\n\n\n\n\n\n\nhelp(plot.ecdf)"
  }
]